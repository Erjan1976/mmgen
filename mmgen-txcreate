#!/usr/bin/env python
#
# mmgen = Multi-Mode GENerator, command-line Bitcoin cold storage solution
# Copyright (C) 2013 by philemon <mmgen-py@yandex.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
mmgen-txcreate: Send BTC to specified addresses
"""

import sys
#from hashlib import sha256

from mmgen.Opts import *
from mmgen.license import *
from mmgen.config import *
from mmgen.tx import *
from mmgen.utils import check_opts, msg, user_confirm
from decimal import Decimal

prog_name = sys.argv[0].split("/")[-1]

help_data = {
	'prog_name': prog_name,
	'desc':    "Send BTC to specified addresses",
	'usage':   "[opts] <address:amount>[,...] <transaction fee> <change address>",
	'options': """
-h, --help                Print this help message
-d, --outdir           d  Specify an alternate directory 'd' for output
-e, --echo-passphrase     Print passphrase to screen when typing it
-i, --info                Display unspent outputs and exit
-q, --quiet               Suppress warnings; overwrite files without asking

Outputs to spend are chosen by the user via a menu.

Ages of transactions are approximate based on an estimated block discovery
time of %s minutes.
""" % mins_per_block
}

short_opts = "hd:eiq"
long_opts  = "help","outdir=","echo_passphrase","info","quiet"

opts,cmd_args = process_opts(sys.argv,help_data,short_opts,long_opts)

# Exits on invalid input
check_opts(opts, ('outdir',))

if debug:
	print "Processed options:     %s" % repr(opts)
	print "Cmd args:              %s" % repr(cmd_args)

if len(cmd_args) == 3:
	rcpt_arg,tx_fee,change_addr = cmd_args
	check_address(change_addr)
elif len(cmd_args) == 2:
	rcpt_arg,tx_fee = cmd_args
	change_addr = ""
elif len(cmd_args) == 0 and 'info' in opts:
	pass
else: usage(help_data)

if not 'info' in opts:
	tx_out = make_tx_out(rcpt_arg)
	for i in tx_out.keys():   check_address(i)
	for i in tx_out.values(): check_btc_amt(i)
	tx_fee   = check_btc_amt(tx_fee)

# Begin execution
c = connect_to_bitcoind()

if not 'quiet' in opts and not 'info' in opts: do_license_msg()

unspent = sort_and_view(c.listunspent())

total = trim_exponent(sum([i.amount for i in unspent]))

msg("Total unspent:   %s BTC" % total)
if 'info' in opts: sys.exit(0)

send_amt = sum(tx_out.values())
msg("Total amount to spend: %s BTC" % send_amt)
msg("%s unspent outputs total" % len(unspent))

while True:
	sel_nums = select_outputs(unspent,"Choose the outputs to spend: ")
	sel_unspent = [unspent[i] for i in sel_nums]
	mmgen_sel,other_sel = [],[]
	for i in sel_nums:
		if verify_mmgen_label(unspent[i].account,check_label_len=True):
			mmgen_sel.append(i)
		else:
			other_sel.append(i)

	if mmgen_sel and other_sel:
		keygen_args = [unspent[i].account.split()[0][9:] for i in mmgen_sel]
		msg("""
NOTE: This transaction uses a mixture of both mmgen and non-mmgen inputs,
which makes the signing process more complicated.  When signing the
transaction, keys for the non-mmgen inputs must be supplied in a separate
file using mmgen-txsign's '-k' option.  Alternatively, you may import the
mmgen keys into the wallet.dat of your offline bitcoind, first running
mmgen-keygen with address list '%s' to generate the keys.  Finally, run
mmgen-txsign with the '-f' option to force the use of wallet.dat as the
key source.
""".strip() % ",".join(sorted(keygen_args)))
		if not user_confirm("Accept?"):
			continue

	total_in = trim_exponent(sum([o.amount for o in sel_unspent]))
	change   = trim_exponent(total_in - (send_amt + tx_fee))

	if change >= 0:
		prompt = "Transaction produces %s BTC in change.  OK?" % change
		if user_confirm(prompt,default_yes=True):
			break
	else:
		msg(txmsg['not_enough_btc'] % change)


if change > 0 and not change_addr:
	msg(txmsg['throwaway_change'] % (change, total_in-tx_fee))
	sys.exit(2)

tx_in = [{"txid":i.txid, "vout":i.vout} for i in sel_unspent]
for i in tx_out.keys(): tx_out[i] = float(tx_out[i])
if change: tx_out[change_addr] = float(change)
tx_hex = c.createrawtransaction(tx_in,tx_out)

msg("Transaction successfully created")
prompt = "View decoded transaction?"
if user_confirm(prompt,default_yes=False):
	view_tx_data(c,[i.__dict__ for i in sel_unspent],tx_hex)

prompt = "Save transaction?"
if user_confirm(prompt,default_yes=True):
	print_tx_to_file(tx_hex,sel_unspent,send_amt,opts)
