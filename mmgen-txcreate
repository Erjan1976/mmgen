#!/usr/bin/env python
#
# mmgen = Multi-Mode GENerator, command-line Bitcoin cold storage solution
# Copyright (C) 2013 by philemon <mmgen-py@yandex.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
mmgen-txcreate: Create a BTC transaction, sending to specified addresses
"""

import sys
#from hashlib import sha256

from mmgen.Opts import *
from mmgen.license import *
import mmgen.config as g
from mmgen.tx import *
from mmgen.util import msg, msg_r, user_confirm
from decimal import Decimal

prog_name = sys.argv[0].split("/")[-1]

help_data = {
	'prog_name': prog_name,
	'desc':    "Create a BTC transaction with outputs to specified addresses",
	'usage':   "[opts]  <addr,amt> ... [change addr] [tx fee] [addr file] ...",
	'options': """
-h, --help                Print this help message
-d, --outdir           d  Specify an alternate directory 'd' for output
-e, --echo-passphrase     Print passphrase to screen when typing it
-i, --info                Display unspent outputs and exit
-q, --quiet               Suppress warnings; overwrite files without
                          prompting

-f, --tx-fee           f  Transaction fee (default: %s BTC)

Transaction inputs are chosen from a list of the user's unpent outputs
via an interactive menu.

Ages of transactions are approximate based on an average block creation
interval of %s minutes.

Addresses on the command line can be Bitcoin addresses or MMGen addresses
of the form <seed ID>:<number>.

To send all inputs (minus TX fee) to a single output, specify one address
with no amount on the command line.
""" % (Decimal(g.tx_fee),g.mins_per_block)
}

short_opts = "hd:eiqf:"
long_opts  = "help","outdir=","echo_passphrase","info","quiet","tx_fee="

opts,cmd_args = process_opts(sys.argv,help_data,short_opts,long_opts)
if 'quiet' in opts: g.quiet = True
check_opts(opts,long_opts)

if g.debug: show_opts_and_cmd_args(opts,cmd_args)

c = connect_to_bitcoind()

if not 'info' in opts:

	tx_out,addr_data,b2m_map,acct_data,change_addr = {},[],{},[],""

	for a in [i for i in cmd_args if match_ext(i,g.addrfile_ext)]:
		if match_ext(a,g.addrfile_ext):
			check_infile(a)
			addr_data.append(parse_addrs_file(a))

	def mm2btc_addr_proc(c,mmadr,acct_data,addr_data,b2m_map):
		btaddr,label = mmgen_addr_to_walletd(c,mmadr,acct_data)
		if not btaddr:
			btaddr,label = mmgen_addr_to_addr_data(mmadr,addr_data)
		b2m_map[btaddr] = mmadr,label
		return btaddr

	for a in [i for i in cmd_args if not match_ext(i,g.addrfile_ext)]:
		if "," in a:
			a1,a2 = a.split(",")
			if is_mmgen_addr(a1) or is_btc_addr(a1):
				btaddr = mm2btc_addr_proc(c,a1,acct_data,addr_data,b2m_map) \
					if is_mmgen_addr(a1) else a1
				if is_btc_amt(a2):
					tx_out[btaddr] = check_btc_amt(a2)
				else:
					msg("%s: invalid amount in argument '%s'" % (a2,a))
					sys.exit(2)
			else:
				msg("%s: unrecognized subargument in argument '%s'" % (a1,a))
				sys.exit(2)
		elif is_mmgen_addr(a) or is_btc_addr(a):
			if change_addr:
				msg("More than one change address specified: %s, %s" %
						(change_addr, a))
				sys.exit(2)
			if is_mmgen_addr(a):
				change_addr = mm2btc_addr_proc(c,a,acct_data,addr_data,b2m_map)
			else:
				change_addr = a
			tx_out[change_addr] = 0
		else:
			msg("%s: unrecognized argument" % a)
			sys.exit(2)

	if not tx_out:
		msg("At least one output must be specified on the command line")
		sys.exit(2)

	tx_fee = opts['tx_fee'] if 'tx_fee' in opts else g.tx_fee
	tx_fee = check_btc_amt(tx_fee)
	if tx_fee > g.max_tx_fee:
		msg("Transaction fee too large: %s > %s" % (tx_fee,g.max_tx_fee))
		sys.exit(2)

if g.debug: show_opts_and_cmd_args(opts,cmd_args)

if not 'info' in opts: do_license_msg(immed=True)

# Begin test
# import mmgen.rpc
# us = eval(get_data_from_file("listunspent.json"))
# End test

us = c.listunspent()

if not us:
	msg("""
No spendable outputs found!  Import addresses with balances into your
watch-only wallet using 'mmgen-addrimport' and then re-run this program.""")
	sys.exit(2)

# write_to_file("listunspent.json",repr(us))
# sys.exit()
unspent = sort_and_view(us)

total = trim_exponent(sum([i.amount for i in unspent]))

msg("Total unspent: %s BTC (%s outputs)" % (total, len(unspent)))
if 'info' in opts: sys.exit(0)

send_amt = sum([tx_out[i] for i in tx_out.keys()])
msg("Total amount to spend: %s%s" % (
		(send_amt or "Unknown")," BTC" if send_amt else ""))

while True:
	sel_nums = select_outputs(unspent,
			"Enter a range or space-separated list of outputs to spend: ")
	msg("Selected outputs: %s" % " ".join(str(i) for i in sel_nums))
	sel_unspent = [unspent[i-1] for i in sel_nums]

	mmaddrs = set([parse_mmgen_label(i.account)[0] for i in sel_unspent])
	mmaddrs.discard("")

	if mmaddrs and len(mmaddrs) < len(sel_unspent):
		msg(txmsg['mixed_inputs'] % ", ".join(sorted(mmaddrs)))
		if not user_confirm("Accept?"):
			continue

	total_in = trim_exponent(sum([i.amount for i in sel_unspent]))
	change   = trim_exponent(total_in - (send_amt + tx_fee))

	if change >= 0:
		prompt = "Transaction produces %s BTC in change.  OK?" % change
		if user_confirm(prompt,default_yes=True):
			break
	else:
		msg(txmsg['not_enough_btc'] % change)

if change > 0 and not change_addr:
	msg(txmsg['throwaway_change'] % change)
	sys.exit(2)

if change_addr in tx_out and not change:
	msg("Warning: Change address will be unused as transaction produces no change")
	del tx_out[change_addr]

for k,v in tx_out.items(): tx_out[k] = float(v)

if change > 0: tx_out[change_addr] = float(change)

tx_in = [{"txid":i.txid, "vout":i.vout} for i in sel_unspent]

if g.debug:
	print "tx_in:", repr(tx_in)
	print "tx_out:", repr(tx_out)

tx_hex = c.createrawtransaction(tx_in,tx_out)
qmsg("Transaction successfully created")
prompt = "View decoded transaction? (y)es, (N)o, (v)iew in pager"
reply = prompt_and_get_char(prompt,"YyNnVv",enter_ok=True)

if reply and reply in "YyVv":
	pager = True if reply in "Vv" else False
	view_tx_data(c,[i.__dict__ for i in sel_unspent],tx_hex,b2m_map,pager=pager)

prompt = "Save transaction?"
if user_confirm(prompt,default_yes=True):
	print_tx_to_file(tx_hex,sel_unspent,send_amt or change,b2m_map,opts)
else:
	msg("Transaction not saved")
