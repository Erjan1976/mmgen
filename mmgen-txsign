#!/usr/bin/env python
#
# mmgen = Multi-Mode GENerator, command-line Bitcoin cold storage solution
# Copyright (C) 2013-2014 by philemon <mmgen-py@yandex.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
mmgen-txsign: Sign a Bitcoin transaction generated by mmgen-txcreate
"""

import sys

import mmgen.config as g
from mmgen.Opts import *
from mmgen.license import *
from mmgen.tx import *
from mmgen.util import msg,qmsg

help_data = {
	'prog_name': g.prog_name,
	'desc':    "Sign Bitcoin transactions generated by {}-txcreate".format(g.proj_name.lower()),
	'usage':   "[opts] <transaction file> .. [mmgen wallet/seed/words/brainwallet file] .. [addrfile] ..",
	'options': """
-h, --help               Print this help message
-d, --outdir=         d  Specify an alternate directory 'd' for output
-e, --echo-passphrase    Print passphrase to screen when typing it
-i, --info               Display information about the transaction and exit
-I, --tx-id              Display transaction ID and exit
-k, --keys-from-file= f  Provide additional keys for non-{pnm} addresses
-K, --all-keys-from-file=f  Like '-k', only use the keyfile as key source
                         for ALL inputs, including {pnm} ones.  Can be used
                         for online signing without an {pnm} seed source.
                         {pnm}-to-BTC mappings can optionally be verified
                         using address file(s) listed on the command line
-P, --passwd-file=    f  Get passphrase from file 'f'
-q, --quiet              Suppress warnings; overwrite files without
                         prompting
-V, --skip-key-preverify Skip optional key pre-verification step
-b, --from-brain=    l,p Generate keys from a user-created password,
                         i.e. a "brainwallet", using seed length 'l' and
                         hash preset 'p'
-w, --use-wallet-dat     Get keys from a running bitcoind
-g, --from-incog         Generate keys from an incognito wallet
-X, --from-incog-hex     Generate keys from an incognito hexadecimal wallet
-G, --from-incog-hidden= f,o,l  Generate keys from incognito data in file
                         'f' at offset 'o', with seed length of 'l'
-m, --from-mnemonic      Generate keys from an electrum-like mnemonic
-s, --from-seed          Generate keys from a seed in .{g.seed_ext} format
""".format(g=g,pnm=g.proj_name),
	'notes': """

Transactions with either {pnm} or non-{pnm} input addresses may be signed.
For non-{pnm} inputs, the bitcoind wallet.dat is used as the key source.
For {pnm} inputs, key data is generated from your seed as with the
{pnl}-addrgen and {pnl}-keygen utilities.

Data for the --from-<what> options will be taken from a file if a second
file is specified on the command line.  Otherwise, the user will be
prompted to enter the data.

In cases of transactions with mixed {pnm} and non-{pnm} inputs, non-{pnm}
keys must be supplied in a separate file (WIF format, one key per line)
using the '--keys-from-file' option.  Alternatively, one may get keys from
a running bitcoind using the '--force-wallet-dat' option.  First import the
required {pnm} keys using 'bitcoind importprivkey'.

For transaction outputs that are {pnm} addresses, {pnm}-to-Bitcoin address
mappings are verified.  Therefore, seed material for these addresses must
be supplied on the command line (but see '--all-keys-from-file').

Seed data supplied in files must have the following extensions:
   wallet:      '.{g.wallet_ext}'
   seed:        '.{g.seed_ext}'
   mnemonic:    '.{g.mn_ext}'
   brainwallet: '.{g.brain_ext}'
""".format(g=g,pnm=g.proj_name,pnl=g.proj_name.lower())
}

opts,infiles = parse_opts(sys.argv,help_data)

for l in (
('tx_id', 'info'),
('keys_from_file','all_keys_from_file')
): warn_incompatible_opts(opts,l)

if "quiet" in opts: g.quiet = True
if 'from_incog_hex' in opts or 'from_incog_hidden' in opts:
	opts['from_incog'] = True
if 'all_keys_from_file' in opts:
	opts['keys_from_file'] = opts['all_keys_from_file']
	opts['skip_key_preverify'] = True

if not infiles: usage(help_data)
for i in infiles: check_infile(i)

c = connect_to_bitcoind()

saved_seeds = {}
tx_files  = [i for i in set(infiles) if get_extension(i) == g.rawtx_ext]
addrfiles = [a for a in set(infiles) if get_extension(a) == g.addrfile_ext]
infiles  = list(set(infiles) - set(tx_files) - set(addrfiles))

if not "info" in opts: do_license_msg(immed=True)

if 'keys_from_file' in opts:
	from mmgen.crypto import mmgen_decrypt
	fn = opts['keys_from_file']
	if get_extension(fn) == g.mmenc_ext:
		enc_d = get_data_from_file(fn,"encrypted keylist")
		dec_d = mmgen_decrypt(enc_d,"",opts)
		if dec_d:
			keys_from_file = remove_comments(dec_d.split("\n"))
		else:
			msg("Decryption of encrypted keylist failed")
			sys.exit(2)
	else:
		keys_from_file = get_lines_from_file(fn,"key data",trim_comments=True)
else: keys_from_file = []

for tx_file in tx_files:
	m = "" if 'tx_id' in opts else "transaction data"
	tx_data = get_lines_from_file(tx_file,m)

	metadata,tx_hex,inputs_data,b2m_map = parse_tx_data(tx_data,tx_file)
	qmsg("Successfully opened transaction file '%s'" % tx_file)

	if 'tx_id' in opts:
		msg(metadata[0])
		sys.exit(0)

	if 'info' in opts:
		view_tx_data(c,inputs_data,tx_hex,b2m_map,metadata)
		sys.exit(0)

# Are inputs mmgen addresses?
	mmgen_inputs = [i for i in inputs_data if parse_mmgen_label(i['account'])[0]]
	other_inputs = [i for i in inputs_data if not parse_mmgen_label(i['account'])[0]]

	if 'all_keys_from_file' in opts: other_inputs = inputs_data

	keys = keys_from_file

	if other_inputs and not keys and not 'use_wallet_dat' in opts:
		missing_keys_errormsg(other_inputs)
		sys.exit(2)

	if other_inputs and keys and not 'skip_key_preverify' in opts:
		a = [i['address'] for i in other_inputs]
		preverify_keys(a, keys)
		opts['skip_key_preverify'] = True

	if 'all_keys_from_file' in opts:
		if addrfiles:
			check_mmgen_to_btc_addr_mappings_addrfile(mmgen_inputs,b2m_map,addrfiles)
		else:
			confirm_or_exit(txmsg['skip_mapping_checks_warning'],"continue")
	else:
		check_mmgen_to_btc_addr_mappings(
				mmgen_inputs,b2m_map,infiles,saved_seeds,opts)

	if len(tx_files) > 1:
		msg("\nTransaction %s/%s:" % (tx_files.index(tx_file)+1,len(tx_files)))

	prompt = "View transaction data? (y)es, (N)o, (v)iew in pager"
	reply = prompt_and_get_char(prompt,"YyNnVv",enter_ok=True)
	if reply and reply in "YyVv":
		p = True if reply in "Vv" else False
		view_tx_data(c,inputs_data,tx_hex,b2m_map,metadata,pager=p)

	sig_data = [
		{"txid":i['txid'],"vout":i['vout'],"scriptPubKey":i['scriptPubKey']}
			for i in inputs_data]

	if mmgen_inputs and not 'all_keys_from_file' in opts:
		ml = [i['account'].split()[0] for i in mmgen_inputs]
		keys += get_keys_for_mmgen_addrs(ml,infiles,saved_seeds,opts)

		if 'use_wallet_dat' in opts:
			sig_tx = sign_tx_with_bitcoind_wallet(c,tx_hex,sig_data,keys,opts)
		else:
			sig_tx = sign_transaction(c,tx_hex,sig_data,keys)
	elif other_inputs:
		if keys:
			sig_tx = sign_transaction(c,tx_hex,sig_data,keys)
		else:
			sig_tx = sign_tx_with_bitcoind_wallet(c,tx_hex,sig_data,keys,opts)

	if sig_tx['complete']:
		prompt = "OK\nSave signed transaction?"
		if user_confirm(prompt,default_yes=True):
			outfile = "tx_%s[%s].%s" % (metadata[0],metadata[1],g.sigtx_ext)
			data = "{}\n{}\n{}\n{}\n".format(
					" ".join(metadata[:2] + [make_timestamp()]),
					sig_tx['hex'],
					repr(inputs_data),
					repr(b2m_map)
				)
			write_to_file(outfile,data,opts,"signed transaction",True,True)
	else:
		msg("failed\nSome keys were missing.  Transaction could not be signed.")
		sys.exit(3)
