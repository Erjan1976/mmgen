#!/usr/bin/env python
#
# mmgen = Multi-Mode GENerator, command-line Bitcoin cold storage solution
# Copyright (C) 2013 by philemon <mmgen-py@yandex.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
mmgen-txsign: Sign a Bitcoin transaction generated by mmgen-txcreate
"""

import sys
#from hashlib import sha256

from mmgen.Opts import *
from mmgen.license import *
from mmgen.config import *
from mmgen.tx import *
from mmgen.utils import *

help_data = {
	'prog_name': sys.argv[0].split("/")[-1],
	'desc':    "Sign a Bitcoin transaction generated by mmgen-txcreate",
	'usage':   "[opts] <transaction file> [mmgen wallet/seed/words/brain file]...",
	'options': """
-h, --help               Print this help message
-d, --outdir          d  Specify an alternate directory 'd' for output
-e, --echo-passphrase    Print passphrase to screen when typing it
-i, --info               Display information about the transaction and exit
-I, --tx_id              Display transaction ID and exit
-k, --keys-from-file  k  Provide additional key data from file 'k'
-P, --passwd-file     f  Get passphrase from file 'f'
-q, --quiet              Suppress warnings; overwrite files without
                         prompting

-b, --from-brain     l,p Generate keys from a user-created password,
                         i.e. a "brainwallet", using seed length 'l' and
                         hash preset 'p' (comma-separated)
-m, --from-mnemonic      Generate keys from an electrum-like mnemonic
-s, --from-seed          Generate keys from a seed in .{} format
-w, --use-wallet-dat     Use the keys in the bitcoind wallet.dat file too

Transactions with either mmgen or non-mmgen input addresses may be signed.
For non-mmgen inputs, the bitcoind wallet.dat is used as the key source.
For mmgen inputs, key data is generated from your seed as with the
mmgen-addrgen and mmgen-keygen utilities.

Data for the --from-<what> options will be taken from a file if a second
file is specified on the command line.  Otherwise, the user will be
prompted to enter the data.

In cases of transactions with mixed mmgen and non-mmgen inputs, non-mmgen
keys must be supplied in a separate file (WIF format, one key per line)
using the '--keys-from-file' option.  Alternatively, one may import the
required mmgen keys into the bitcoind wallet.dat and use the
'--force-wallet-dat' option.

Seed data supplied in files must have the following extensions:
   wallet:      '.{}'
   seed:        '.{}'
   mnemonic:    '.{}'
   brainwallet: '.{}'
""".format(seed_ext,wallet_ext,seed_ext,mn_ext,brain_ext)
}

short_opts = "hd:eiIk:P:qb:msw"
long_opts  = "help","outdir=","echo_passphrase","info","tx_id",\
			  "keys_from_file=","passwd_file=","quiet","from_brain=",\
			  "from_mnemonic","from_seed","use_wallet_dat"

opts,infiles = process_opts(sys.argv,help_data,short_opts,long_opts)

# Exits on invalid input
check_opts(opts, ('outdir','from_brain'))
if 'keys_from_file' in opts: check_infile(opts['keys_from_file'])

if not infiles: usage(help_data)
for i in infiles: check_infile(i)


def get_keys_for_mmgen_addrs(mmgen_addrs,infiles):

	seed_ids = list(set([i['account'][:8] for i in mmgen_addrs]))
	seed_ids_save = seed_ids[0:]
	keys = []

	while seed_ids:
		infile = False
		if infiles:
			infile = infiles.pop()
			seed = get_seed(infile,opts)
		elif "from_brain" in opts or "from_mnemonic" in opts or "from_seed" in opts:
			msg("Need data for seed ID %s" % seed_ids[0])
			seed = get_seed_retry("",opts)
		else:
			b,p,v = ("A seed","","is") if len(seed_ids) == 1 else ("Seed","s","are")
			msg("ERROR: %s source%s %s required for the following seed ID%s: %s" %
					(b,p,v,p," ".join(seed_ids)))
			sys.exit(2)

		seed_id = make_chksum_8(seed)
		if seed_id in seed_ids:
			seed_ids.remove(seed_id)
			seed_id_addrs = [
				int(i['account'].split()[0][9:]) for i in mmgen_addrs
					if i['account'][:8] == seed_id]

			from mmgen.addr import generate_keys
			keys += [i['wif'] for i in generate_keys(seed, seed_id_addrs)]
		else:
			if seed_id in seed_ids_save:
				msg_r("Ignoring duplicate seed source")
				if infile: msg(" '%s'" % infile)
				else:      msg(" for ID %s" % seed_id)
			else:
				msg("Seed source produced an invalid seed ID (%s)" % seed_id)
				if infile:
					msg("Invalid input file: %s" % infile)
					sys.exit(2)

	return keys


def sign_tx_with_bitcoind_wallet(c,tx_hex,sig_data,keys):

	try:
		sig_tx = sign_transaction(c,tx_hex,sig_data,keys)
	except:
		from mmgen.rpc import exceptions
		msg("Using keys in wallet.dat as per user request")
		prompt = "Enter passphrase for bitcoind wallet: "
		while True:
			passwd = get_bitcoind_passphrase(prompt,opts)

			try:
				c.walletpassphrase(passwd, 9999)
			except exceptions.WalletPassphraseIncorrect:
				msg("Passphrase incorrect")
			else:
				msg("Passphrase OK"); break

		sig_tx = sign_transaction(c,tx_hex,sig_data,keys)

		msg("Locking wallet")
		try:
			c.walletlock()
		except:
			msg("Failed to lock wallet")

	return sig_tx


def missing_keys_errormsg(other_addrs):
	msg("""
A key file (option '-f') or wallet.dat (option '-w') must be supplied
for the following non-mmgen address%s: %s""" %
	("" if len(other_addrs) == 1 else "es",
	" ".join([i['address'] for i in other_addrs])
	  ))

# Begin execution

c = connect_to_bitcoind()

tx_file = infiles.pop(0)
m = "" if 'tx_id' in opts else "transaction data"
tx_data = get_lines_from_file(tx_file,m)

metadata,tx_hex,sig_data,inputs_data = parse_tx_data(tx_data,tx_file)

if 'tx_id' in opts:
	msg(metadata[0])
	sys.exit(0)

if 'info' in opts:
	view_tx_data(c,inputs_data,tx_hex,metadata)
	sys.exit(0)

if not 'quiet' in opts: do_license_msg()

msg("Successfully opened transaction file '%s'" % tx_file)

if user_confirm("View transaction data? ",default_yes=False):
	view_tx_data(c,inputs_data,tx_hex,metadata)


# Are inputs mmgen addresses?
mmgen_addrs,other_addrs = [],[]

for i in inputs_data:
	if verify_mmgen_label(i['account']):
		mmgen_addrs.append(i)
	else:
		other_addrs.append(i)


if 'keys_from_file' in opts:
	keys = get_lines_from_file(opts['keys_from_file'],"key data")
else:
	keys = []

if mmgen_addrs:
	if other_addrs and not keys and not 'use_wallet_dat' in opts:
		missing_keys_errormsg(other_addrs)
		sys.exit(2)

	keys += get_keys_for_mmgen_addrs(mmgen_addrs,infiles)

	if 'use_wallet_dat' in opts:
		sig_tx = sign_tx_with_bitcoind_wallet(c,tx_hex,sig_data,keys)
	else:
		sig_tx = sign_transaction(c,tx_hex,sig_data,keys)
elif other_addrs:
	if 'use_wallet_dat' in opts:
		sig_tx = sign_tx_with_bitcoind_wallet(c,tx_hex,sig_data,keys)
	else:
		if keys:
			sig_tx = sign_transaction(c,tx_hex,sig_data,keys)
		else:
			missing_keys_errormsg(other_addrs)
			sys.exit(2)

if sig_tx['complete']:
	msg("Signing completed")
	prompt = "Save signed transaction?"
	if user_confirm(prompt,default_yes=True):
		print_signed_tx_to_file(tx_hex,sig_tx['hex'],metadata,opts)
else:
	msg("Some keys were missing.  Transaction could not be signed.")
	sys.exit(3)
