#!/usr/bin/env python
#
# mmgen = Multi-Mode GENerator, command-line Bitcoin cold storage solution
# Copyright (C)2013-2016 Philemon <mmgen-py@yandex.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

"""
test/gentest.py:  Bitcoin key/address generation tests for the MMGen suite
"""

import sys,os
pn = os.path.dirname(sys.argv[0])
os.chdir(os.path.join(pn,os.pardir))
sys.path.__setitem__(0,os.path.abspath(os.curdir))

from binascii import hexlify

# Import these _after_ local path's been added to sys.path
from mmgen.common import *
from mmgen.bitcoin import hextowif,privnum2addr

start_mscolor()

rounds = 100
opts_data = {
	'desc': "Test addresses generated by {} against output of 'keyconv'".format(g.proj_name),
	'usage':'[options] [rounds]',
	'options': """
-h, --help         Print this help message
-s, --system       Test scripts and modules installed on system rather than
                   those in the repo root
-v, --verbose      Produce more verbose output
""",
	'notes': """

'keyconv' is the address generation utility from the well-known vanitygen
package.  If it's installed on your system, {pnm} will use it by default to
generate Bitcoin addresses.  Otherwise, it falls back on its own internal
routines, which use the Python ecdsa library.

rounds is {} by default.
""".format(rounds,pnm=g.proj_name)
}
cmd_args = opts.init(opts_data,add_opts=['exact_output'])

if len(cmd_args) == 1:
	try:
		rounds = int(cmd_args[0])
		assert rounds > 0
	except:
		die(1,"'rounds' must be a positive integer")

elif len(cmd_args) > 1:
	opts.usage(opts_data)

if opt.system: sys.path.pop(0)

from mmgen.addr import test_for_keyconv
if not test_for_keyconv(silent=True):
	die(1,"To run this test, you must install 'keyconv' from the vanitygen package.")

m = "Comparing {}'s internally generated addresses against output of 'keyconv'"
msg(green(m.format(g.proj_name)))

from subprocess import check_output
for i in range(1,rounds+1):
	msg_r('\rRound %s/%s ' % (i,rounds))
	sec = hexlify(os.urandom(32))
	wif = hextowif(sec)
	a = privnum2addr(int(sec,16))
	vmsg('\nkey:  %s\naddr: %s\n' % (wif,a))
	b = check_output(['keyconv', wif]).split()[1]
	if a != b:
		msg_r(red('\nERROR: Addresses do not match!'))
		die(3,"""
  sec key: {}
  WIF key: {}
  {pnm}:   {}
  keyconv: {}
""".format(sec,wif,a,b,pnm=g.proj_name).rstrip())

msg(green(('\n','')[bool(opt.verbose)] + 'OK'))
